### 读 林锐的高质量C/C++编程指南的一些笔记

主要记录一下平常写代码时不太注意的地方

早上写代码时碰到两个问题，不是特别明白，于是代码被搁置了。晚上下班想看看关于代码质量的书，翻到了这一本，把其中 C 语言的部分看了一遍，很神奇的是正好解决了我早上遗留下来的两个问题，真的是很幸运！！！

1. 函数中的字符串指针 `return` 后，函数外打印为空。
2. 另外一个是函数的参数传入一个指针 `p`，然后函数内 `malloc` 申请个块内存，赋值给 `p`,函数外部 `p` 依然是 `NULL`

### 命名
1. 变量命名： 名词 或 形容+名词
2. 函数命名： 动词 或 动词+名词
3. 正确的反义词组命名相斥的变量会函数：  `getValue` `setValue`
4. 避免出现数字序：  `value1`  `value2`

### 代码
如果代码行中的运算符比较多，用括号确定表达式的操作顺序

### if 比较
1. 不可将`布尔变量`直接与 `TRUE`、`FALSE` 或者 `1`、`0` 进行比较
```c
if (flag)
if (!flag)
```

2. 应当将`整型`变量用`==`或`!=`直接与 `0` 比较。
```c
if (value == 0)
if (value != 0)
```

3. 不可将`浮点变量`用`==`或`!=`与任何数字比较。

浮点数精度问题，应该尽量转化成 `<=` 或 `>=`

4. 应当将`指针变量`用 `==` 或 `!=` 与 `NULL` 比较。

### 效率

1. 多重循环中，如果有可能，应当将最长的循环放在最内层，最短的
循环放在最外层，以减少 CPU `跨切循环层`的次数。

2. 建议 `for` 语句的循环控制变量的取值采用 `半开半闭区间` (一边有等于，一边没有等于)写法。`0 =< x < N`，起点到终点的间隔正好为 N

3. 错误是程序员自己造成的，不是 `goto` 的过错。`goto` 语句至少有一处可显神通，它能从多重循环体中咻地一下子跳到外面，用不着写很多次的 `break` 语句;（再比如 `SeasLog`  `TCP` 重连） 

### 函数
1. 如果函数没有参数，则用 void 填充。
```c
float GetValue(void); 
```

2. 如果参数是指针，且仅作输入用，则应在类型前加 const

3. 尽量不要使用类型和数目不确定的参数。丧失了严格的类型安全检查

4. 不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用 `return` 语句返回。(指针传进去，函数内部直接修改，发生错误 `return FALSE`)

5. 有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，可以附加返回值。

例如 `strcpy` 本不需要返回值

```c
char str[20];
int length = strlen(strcpy(str, “Hello World”)); 
```

6. 函数入口使用断言(assert)

* `assert` 不是一个仓促拼凑起来的宏。为了不在程序的 `Debug` 版本和 `Release` 版本引起差别，`assert` 不应该产生任何副作用。所以 `assert` 不是函数，而是宏。
* 如果程序在 `assert` 处终止了，并不是说含有`assert` 的函数有错误，而是调用者出了差错。
* `assert` 应该捕捉非法情况，而不是错误情况，错误情况属于正常的逻辑流程

7. return 语句不可返回指向“栈内存”(好吧，这是第一个问题，今天写 `web server` 碰到了)

```c
char * Func(void)
{
    char str[] = “hello world”; // str 的内存位于栈上
    return str; // 将导致错误
}
```

### 内存

1. 内存分配未成功，却使用了它。 
一定要 判断是否分配成功，`p != NULL`, 函数入口处使用断言 `assert(p!=NULL)` 检查

2. 内存分配虽然成功，但是尚未`初始化`就引用它。尤其是字符串和数组，字符串经常抽风。

3. `free` 或 `delete` 释放了内存后，一定要将指针设置为 NULL。防止产生 `野指针`

4. C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它

5. 指向指针的指针，我们可以用函数返回值来传递动态内存。

```c
void GetMemory(char *p, int num)
{
    //新指针会把 p 指针覆盖，p 以及不是原来的 p
    p = (char *)malloc(sizeof(char) * num);
}
void Test(void)
{
    char *str = NULL;
    GetMemory(str, 100); // str 仍然为 NULL
    strcpy(str, "hello"); // 运行错误
}
```

```c
void GetMemory2(char **p, int num)
{
    // 如果用指针的指针，正好可以指向新生成的这个指针
    *p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
    char *str = NULL;
    GetMemory2(&str, 100); // 注意参数是 &str，而不是 str
    strcpy(str, "hello");
    cout<< str << endl;
    free(str);
}
```

6. 指针 `p` 被 `free` 以后其地址仍然不变（非 NULL），只是该地址对应的内存是垃圾 `p` 成了 `野指针`。必须把 `p` 设置为 `NULL`

7. 如果输入参数采用`指针传递`，那么加 `const` 修饰可以防止意外地改动该指针，如果是`值传递`，则并不需要，因为值传递本身就会复制出新值供函数使用。

### 如果可能的话，使用 `PC-Lint`、`LogiScope` 等工具进行代码审查。

> 2018-06-04 22:59